# üõí E-Commerce Customer Segmentation (RFM + K-Means)

![Python](https://img.shields.io/badge/Python-3.8%2B-blue)
![Machine Learning](https://img.shields.io/badge/Machine%20Learning-KMeans-orange)
![SQL](https://img.shields.io/badge/SQL-DuckDB-green)
![Status](https://img.shields.io/badge/Status-Completed-brightgreen)

## üìå Project Overview
This project focuses on **Customer Segmentation** for an e-commerce platform using the **RFM (Recency, Frequency, Monetary)** model. 

Instead of simple threshold-based grouping, I utilized **Unsupervised Machine Learning (K-Means Clustering)** to mathematically identify distinct customer groups. This approach allows businesses to target specific clusters (e.g., "VIPs" vs. "At-Risk") with personalized marketing strategies.

Additionally, an **SQL implementation** using `DuckDB` is included to demonstrate how these metrics can be calculated directly within a data warehouse environment.

## üìä The Dataset
**Source:** [UCI Machine Learning Repository - Online Retail II](https://archive.ics.uci.edu/ml/datasets/Online+Retail+II)  
**Description:** A transactional dataset containing all transactions occurring between 01/12/2010 and 09/12/2011 for a UK-based and registered non-store online retail.

* **Records:** 541,909 rows
* **Key Features:** `InvoiceNo`, `StockCode`, `Description`, `Quantity`, `InvoiceDate`, `UnitPrice`, `CustomerID`, `Country`.

## üõ†Ô∏è Tech Stack & Tools
* **Language:** Python
* **Data Manipulation:** Pandas, NumPy
* **Database/SQL:** DuckDB (for SQL querying on DataFrames)
* **Machine Learning:** Scikit-Learn (K-Means Clustering, StandardScaler)
* **Visualization:** Plotly (Interactive 3D Charts), Seaborn, Matplotlib

## ‚öôÔ∏è Methodology

### 1. Data Preprocessing
* Handled missing values (dropped null `CustomerID`).
* Removed cancelled transactions (negative `Quantity`).
* Converted `InvoiceDate` to datetime objects for time-series analysis.

### 2. Feature Engineering (RFM)
Calculated the following metrics for each customer:
* **Recency (R):** Days since the last purchase.
* **Frequency (F):** Total number of transactions.
* **Monetary (M):** Total revenue generated by the customer.

### 3. Machine Learning (Clustering)
* **Log Transformation:** Applied to handle the right-skewed distribution of data.
* **Scaling:** Used `StandardScaler` to normalize metrics.
* **K-Means:** Applied the Elbow Method to determine optimal `k` (Clusters = 3).

### 4. SQL Integration
Demonstrated how to replicate the Python logic using standard SQL queries for enterprise scalability.

## üìà Key Results & Insights

| Cluster | Profile Name | Characteristics | Strategy |
| :--- | :--- | :--- | :--- |
| **0** | **VIP Customers** | High Spend, Recent Purchase, Frequent. | Loyalty programs, Early access to products. |
| **1** | **New/Occasional** | Low Spend, Recent Purchase, Low Frequency. | Onboarding emails, "Welcome Back" coupons. |
| **2** | **At-Risk / Churn** | High Past Spend, No Recent Purchase. | Aggressive retention campaigns, Win-back offers. |

*(Insert your 3D Plotly screenshot here)*

## üíª How to Run This Project

1.  **Clone the repo:**
    ```bash
    git clone [https://github.com/yourusername/customer-segmentation-rfm.git](https://github.com/yourusername/customer-segmentation-rfm.git)
    ```
2.  **Install dependencies:**
    ```bash
    pip install pandas numpy scikit-learn plotly duckdb matplotlib seaborn
    ```
3.  **Run the Notebook:**
    Open `Customer_Segmentation.ipynb` in Jupyter Notebook or Google Colab.

## üìú SQL Query Example
Here is a snippet of the SQL logic used to rank customers based on spend:

```sql
SELECT 
    CustomerID,
    NTILE(5) OVER (ORDER BY monetary ASC) as monetary_score
FROM rfm_table
ORDER BY monetary_score DESC;
